import { Commitment, Connection, Keypair, PublicKey, Transaction } from "@solana/web3.js";
import { PumpFun, IDL } from "./IDL";
import { BN } from 'bn.js';

import { Program, Provider, AnchorProvider } from "@coral-xyz/anchor";
import NodeWallet from "@coral-xyz/anchor/dist/cjs/nodewallet";
import { struct, bool, u64, Layout } from "@coral-xyz/borsh";
import { createAssociatedTokenAccountInstruction, getAccount, getAssociatedTokenAddress } from "@solana/spl-token";

export const PUMPFUN_PROGRAM_ID = "6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P";
export const GLOBAL_ACCOUNT_SEED = "global";
export const MINT_AUTHORITY_SEED = "mint-authority";
export const BONDING_CURVE_SEED = "bonding-curve";
export const METADATA_SEED = "metadata";
export const feeRecipient = new PublicKey("CebN5WGQ4jvEPvsVU4EoHEpgzq1VV7AbicfhtW4xC9iM");


export class PumpFunSDK {

    public connection: Connection;
    public program: Program<PumpFun>;

    constructor(connection: Connection, commitment: Commitment = "finalized") {
        this.connection = connection;
        const wallet = new NodeWallet(new Keypair());
        const provider = new AnchorProvider(connection, wallet, {
            commitment: commitment,
        });
        this.program = new Program<PumpFun>(IDL as PumpFun, provider);
    }

    public getBondingCurveStatus = async (connection: Connection, mint: PublicKey, commitment: Commitment = "finalized") => {
        const tokenAccount = await connection.getAccountInfo(
            this.getBondingCurvePDA(mint),
            commitment
        );
        if (!tokenAccount) {
            return null;
        }
        const structure = struct([
            u64("discriminator"),
            u64("virtualTokenReserves"),
            u64("virtualSolReserves"),
            u64("realTokenReserves"),
            u64("realSolReserves"),
            u64("tokenTotalSupply"),
            bool("complete"),
        ]);
        let value = structure.decode(tokenAccount.data);
        return {
            discriminator: BigInt(value.discriminator),
            virtualTokenReserves: BigInt(value.virtualTokenReserves),
            virtualSolReserves: BigInt(value.virtualSolReserves),
            realTokenReserves: BigInt(value.realTokenReserves),
            realSolReserves: BigInt(value.realSolReserves),
            tokenTotalSupply: BigInt(value.tokenTotalSupply),
            complete: value.complete
        };
    }

    public getBondingCurvePDA = (mint: PublicKey) => {
        return PublicKey.findProgramAddressSync(
            [Buffer.from(BONDING_CURVE_SEED), mint.toBuffer()],
            new PublicKey(PUMPFUN_PROGRAM_ID)
        )[0];
    }

    public getBuyTokenAmount = async (connection: Connection, mint: PublicKey, amount: bigint, commitment: Commitment = "finalized") => {
        const bondingCurveStatus = await this.getBondingCurveStatus(connection, mint, commitment);
        if (!bondingCurveStatus) {
            return 0n;
        }
        if (bondingCurveStatus.complete) {
            console.log("BondingCurve is complete");
            return 0n;
        }
        if (amount <= 0n) {
            return 0n;
        }
        let n = bondingCurveStatus.virtualSolReserves * bondingCurveStatus.virtualTokenReserves;
        let i = bondingCurveStatus.virtualSolReserves + amount;
        let r = n / i + 1n;
        let s = bondingCurveStatus.virtualTokenReserves - r;
        return s < bondingCurveStatus.realTokenReserves ? s : bondingCurveStatus.realTokenReserves;
    }

    public getSellSolAmount = async (connection: Connection, mint: PublicKey, amount: bigint, commitment: Commitment = "finalized") => {
        const bondingCurveStatus = await this.getBondingCurveStatus(connection, mint, commitment);
        if (!bondingCurveStatus) {
            return 0n;
        }
        if (bondingCurveStatus.complete) {
            console.log("Curve is complete");
            return 0n;
        }
        if (amount <= 0n) {
            return 0n;
        }
        let n = (amount * bondingCurveStatus.virtualSolReserves) / (bondingCurveStatus.virtualTokenReserves + amount);
        return n;
    }

    public getBuyTransaction = async (connection: Connection, mint: PublicKey, buyer: PublicKey, tokenAmount: bigint, solAmount: bigint, commitment: Commitment = "finalized") => {
        const associatedBondingCurve = await getAssociatedTokenAddress(
            mint,
            this.getBondingCurvePDA(mint),
            true
        );
        const associatedUser = await getAssociatedTokenAddress(mint, buyer, false);
        let transaction = new Transaction();
        try {
            await getAccount(connection, associatedUser, commitment);
        } catch (e) {
            transaction.add(
                createAssociatedTokenAccountInstruction(
                    buyer,
                    associatedUser,
                    buyer,
                    mint
                )
            );
        }
        transaction.add(
            await this.program.methods
                .buy(new BN(tokenAmount.toString()), new BN(solAmount.toString()))
                .accounts({
                    feeRecipient: feeRecipient,
                    mint: mint,
                    associatedBondingCurve: associatedBondingCurve,
                    associatedUser: associatedUser,
                    user: buyer,
                })
                .transaction()
        );
        return transaction;
    }

    public getSellTransaction = async (connection: Connection, mint: PublicKey, seller: PublicKey, tokenAmount: bigint, solAmount: bigint, commitment: Commitment = "finalized") => {
        const associatedBondingCurve = await getAssociatedTokenAddress(
            mint,
            this.getBondingCurvePDA(mint),
            true
        );
        const associatedUser = await getAssociatedTokenAddress(mint, seller, false);
        let transaction = new Transaction();
        transaction.add(
            await this.program.methods
                .sell(new BN(tokenAmount.toString()), new BN(solAmount.toString()))
                .accounts({
                    feeRecipient: feeRecipient,
                    mint: mint,
                    associatedBondingCurve: associatedBondingCurve,
                    associatedUser: associatedUser,
                    user: seller,
                })
                .transaction()
        );
        return transaction;
    }
}

